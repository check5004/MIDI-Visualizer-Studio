import 'dart:ui';

class PathUtils {
  /// Parses a simple SVG path string (M, L, Z commands) into a list of Offsets.
  /// This is tailored for the paths generated by the flood fill (polygons).
  static List<Offset> parsePath(String pathData) {
    final points = <Offset>[];
    final parts = pathData.split(RegExp(r'[ ,]+'));

    for (int i = 0; i < parts.length; i++) {
      final cmd = parts[i];
      if (cmd == 'M' || cmd == 'L') {
        if (i + 2 < parts.length) {
          final x = double.tryParse(parts[i + 1]) ?? 0.0;
          final y = double.tryParse(parts[i + 2]) ?? 0.0;
          points.add(Offset(x, y));
          i += 2;
        }
      } else if (cmd == 'Z') {
        // Close path - usually implies connecting back to first point
        // We don't need to add a point for Z if we treat it as a closed polygon
      }
    }
    return points;
  }

  /// Generates an SVG path string from a list of Offsets.
  static String generatePath(List<Offset> points) {
    if (points.isEmpty) return '';
    final buffer = StringBuffer();
    buffer.write('M ${points[0].dx.toStringAsFixed(2)} ${points[0].dy.toStringAsFixed(2)}');
    for (int i = 1; i < points.length; i++) {
      buffer.write(' L ${points[i].dx.toStringAsFixed(2)} ${points[i].dy.toStringAsFixed(2)}');
    }
    buffer.write(' Z');
    return buffer.toString();
  }

  /// Smooths a polygon using a combination of simplification and corner-cutting.
  /// [amount] controls the smoothing strength.
  /// Values > 1.0 will increase the number of iterations and simplification tolerance.
  static List<Offset> smoothPath(List<Offset> points, double amount) {
    if (points.length < 3 || amount <= 0) return points;

    // 1. Simplify first to remove jitter/waves
    // Tolerance increases with amount.
    // e.g. amount 1.0 -> tolerance 1.0
    // amount 5.0 -> tolerance 5.0
    final tolerance = amount * 0.5; // Adjust this factor as needed
    List<Offset> currentPoints = simplifyPath(points, tolerance);

    // 2. Apply corner cutting (Chaikin)
    // Amount determines iterations and ratio.
    int maxIterations = amount.ceil();

    for (int iter = 1; iter <= maxIterations; iter++) {
      if (currentPoints.length > 2000) break; // Safety break

      double ratio = 0.5;
      if (iter == maxIterations) {
        // Last iteration uses the fractional part
        double remainder = amount - (iter - 1);
        ratio = 0.5 * remainder.clamp(0.0, 1.0);
      }

      if (ratio <= 0.001) continue; // Skip if ratio is negligible

      final nextPoints = <Offset>[];
      for (int i = 0; i < currentPoints.length; i++) {
        final p0 = currentPoints[i];
        final p1 = currentPoints[(i + 1) % currentPoints.length];

        final q = Offset(p0.dx + (p1.dx - p0.dx) * ratio, p0.dy + (p1.dy - p0.dy) * ratio);

        final r = Offset(p1.dx - (p1.dx - p0.dx) * ratio, p1.dy - (p1.dy - p0.dy) * ratio);

        nextPoints.add(q);
        nextPoints.add(r);
      }
      currentPoints = nextPoints;
    }

    return currentPoints;
  }

  /// Simplifies a path using the Ramer-Douglas-Peucker algorithm.
  static List<Offset> simplifyPath(List<Offset> points, double tolerance) {
    if (points.length <= 2) return points;
    if (tolerance <= 0) return points;

    // Find the point with the maximum distance
    double maxDistance = 0;
    int index = 0;
    final end = points.length - 1;

    for (int i = 1; i < end; i++) {
      final d = _perpendicularDistance(points[i], points[0], points[end]);
      if (d > maxDistance) {
        index = i;
        maxDistance = d;
      }
    }

    final result = <Offset>[];

    // If max distance is greater than epsilon, recursively simplify
    if (maxDistance > tolerance) {
      final firstPart = simplifyPath(points.sublist(0, index + 1), tolerance);
      final secondPart = simplifyPath(points.sublist(index, end + 1), tolerance);

      result.addAll(firstPart.sublist(0, firstPart.length - 1));
      result.addAll(secondPart);
    } else {
      result.add(points[0]);
      result.add(points[end]);
    }

    return result;
  }

  static double _perpendicularDistance(Offset point, Offset lineStart, Offset lineEnd) {
    if (lineStart.dx == lineEnd.dx && lineStart.dy == lineEnd.dy) {
      return (point - lineStart).distance;
    }

    final dx = lineEnd.dx - lineStart.dx;
    final dy = lineEnd.dy - lineStart.dy;

    // Normalize
    final mag = (dx * dx + dy * dy); // squared magnitude

    final u = ((point.dx - lineStart.dx) * dx + (point.dy - lineStart.dy) * dy) / mag;

    Offset intersection;
    if (u < 0 || u > 1) {
      // Closest point is one of the ends
      final d1 = (point - lineStart).distance;
      final d2 = (point - lineEnd).distance;
      return d1 < d2 ? d1 : d2;
    } else {
      intersection = Offset(lineStart.dx + u * dx, lineStart.dy + u * dy);
      return (point - intersection).distance;
    }
  }
}
